---나동빈 코드 >>> 
def sortingmerge(stt,mid,end,L):
    i=stt
    j=mid+1
    k=stt
    while i<=mid and j<=end:
        if L[i]>=L[j]:
            sol[k]=L[i]
            i+=1
        else:
            sol[k]=L[j]
            j+=1
        k+=1
    
    if i>mid:
        while j<=end:
            sol[k]=L[j]
            j+=1
            k+=1
    if j>end:
        while i<=mid:
            sol[k]=L[i]
            i+=1
            k+=1
    
    for p in range(stt,end+1):
        L[p]=sol[p]

def mergeSort(stt,end,L):
    global sol
    sol=[0]*len(L)
    mid=(stt+end)//2
    #재귀의 종결조건 : 하나 하나씩 나뉘는 경우
    if stt==end:
        return
    
    mergeSort(stt,mid,L)
    mergeSort(mid+1,end,L)
    sortingmerge(stt,mid,end,L)

mergeSort(0,len(num)-1,num)




---2회차 코드
::: 그렇게 깔끔한 코드라고 볼 수는 없다. 다만 병합정렬을 이제 이해하고 있는 정도라고 보면 될 듯하다.


global L
L=[6,10,2]


def mergeSort(st,end,L):
    if st==end: #종결조건
        return L[st]
    mid=(st+end)//2
    mergeSort(st,mid,L)
    mergeSort(mid+1,end,L)
    sortOfmerge(st,mid,end,L)

#그냥 숫자 정렬 함수만들고 덧입히는 방식으로 가자

def sortOfmerge(st,mid,end,L):
    sol=[]
    i=st
    j=mid+1
    while i<=mid and j<=end:
        if L[i] <= L[j]: #값이 더 작으면 sorted에 넣고 i전진
            sol.append(L[i])
            i+=1
        else:
            sol.append(L[j])
            j+=1
    
    while i<=mid:
        sol.append(L[i])
        i+=1
    while j<=end:
        sol.append(L[j])
        j+=1

    #L의 값을 변경해준다
    l=0
    while l <= (end-st):
        L[st+l]=sol[l]
        l+=1

mergeSort(0,len(L)-1,L)
print(L)
