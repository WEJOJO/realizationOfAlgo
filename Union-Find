#합집합 찾기 알고리즘
#배열의 형식으로 부모의 값을 매겨놓음
#parent[]속에는 모든 노드들이 들어가있어야 함. 서로 다른 그래프라고 할 지라도 들어있어야 함
#이것 또한 계수정렬을 해야할 것 같네 >> 일단은 그렇게 해보자

#1. parent배열 초기화 input만큼 인덱스에 넣기
#2. getParent 함수 구현해야함 >> 방법은 재귀함수
#3. 서로의 부모를 반환하고 값이 같으면 같은 부모안에 있다는 뜻으로 받아들인다
#4. 합치는 union함수는 만든다
#5. 같은 부모에 있는지 판단하는 함수를 만든다

parent=[0]*101 #부모 배열

class Node:
    def __init__(self,item):
        self.data = item
        parent[self.data]=self.data #생성과 동시에 자신을 부모로 한다
        self.link = [] #노드의 링크를 확인하는 것 #추후에 연결할 때는 append를 써야한다

def getParent(parent,x): #int x
    if parent[x]==x:
        return x
    else:
        parent[x]=getParent(parent,parent[x])
    return parent[x] else부분에 그냥 바로 return getParent()의 값을 넣어도 상관없이 반환하지만 강의대로 불려올 때마다 적어도 불린 것의 값은 수정해주도록 바꾼 부분이다.
    
def union(parent,x,y): #서로 추가함
    x=getParent(parent,x)
    y=getParent(parent,y)
    if x < y:
        parent[y]=x
    else: #편의상 else사용했으나 같은 경우가 포함되어 있다.
        parent[x]=y

def findParent(parent,x,y):
    x=getParent(parent,x)
    y=getParent(parent,y)
    if x==y:
        return True
    else:
        return False

a=Node(1)
b=Node(2)
c=Node(3)
d=Node(4)
e=Node(5)
f=Node(6)
g=Node(7)
h=Node(8)

union(parent,a.data,b.data)
union(parent,b.data,c.data)
union(parent,c.data,d.data)
union(parent,e.data,f.data)
union(parent,f.data,g.data)
union(parent,g.data,h.data)
union(parent,d.data,g.data)
